{% extends "base.html" %}

{% block title %}Forum - {{ username }}{% endblock %}

{% block content %}
<div class="row h-100">
    <!-- Sidebar -->
    <div class="col-md-3 p-0">
        <!-- Forum Threads -->
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Threads</h5>
                <button id="createThreadBtn" class="btn btn-sm btn-success">New Thread</button>
            </div>
            <div class="card-body p-0">
                <div id="threadsList" class="thread-list">
                    <div class="thread-item text-muted p-3">Loading threads...</div>
                </div>
            </div>
        </div>
        
        <!-- Online Users -->
        <div class="card">
            <div class="card-header">
                <h5>Online Users</h5>
            </div>
            <div class="card-body p-0">
                <div id="usersList" class="user-list">
                    <div class="p-3 text-muted">Loading users...</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main Content -->
    <div class="col-md-9 p-0">
        <!-- Public Thread Area -->
        <div id="publicChatArea" class="card h-100">
            <div class="card-header">
                <h5 id="publicChatTitle">Welcome to the Forum! Create or join a thread to chat.</h5>
            </div>
            <div class="card-body d-flex flex-column">
                <div id="publicChatMessages" class="chat-container flex-grow-1 mb-3 d-none"></div>
                <div class="input-group d-none" id="publicInputGroup">
                    <input type="text" id="publicMessageInput" class="form-control bg-dark text-light" placeholder="Type your message...">
                    <button id="publicSendMessageBtn" class="btn btn-primary">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Private Chat Area (hidden) -->
        <div id="privateChatArea" class="card h-100 d-none">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 id="privateChatTitle">Private Chat</h5>
                <div>
                    <button id="shareScreenBtn" class="btn btn-sm btn-primary me-2">Share Screen</button>
                    <button id="stopScreenBtn" class="btn btn-sm btn-danger me-2 d-none">Stop Sharing</button>
                    <button id="closeChatBtn" class="btn btn-sm btn-secondary">Close</button>
                </div>
            </div>
            <div class="card-body d-flex flex-column">
                <div id="screenShareContainer" class="screen-share-container d-none mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span id="screenShareStatus" class="text-light">Screen sharing active</span>
                        <button id="stopViewingBtn" class="btn btn-sm btn-outline-secondary">Stop Viewing</button>
                    </div>
                    <video id="screenVideo" autoplay playsinline></video>
                </div>
                <div id="privateChatMessages" class="chat-container flex-grow-1 mb-3"></div>
                <div class="input-group">
                    <input type="text" id="messageInput" class="form-control bg-dark text-light" placeholder="Type your message...">
                    <button id="sendMessageBtn" class="btn btn-primary">Send</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Create Thread Modal -->
<div class="modal fade" id="createThreadModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-light">
            <div class="modal-header">
                <h5 class="modal-title">Create New Thread</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="text" id="threadTitle" class="form-control bg-dark text-light mb-3" placeholder="Thread title...">
                <textarea id="threadDescription" class="form-control bg-dark text-light" placeholder="Optional description..." rows="3"></textarea>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" id="submitThreadBtn" class="btn btn-success">Create</button>
            </div>
        </div>
    </div>
</div>

<!-- Incoming Private Chat Modal -->
<div class="modal fade" id="chatInvitationModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content bg-dark text-light">
            <div class="modal-header">
                <h5 class="modal-title">Private Chat Invitation</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p id="invitationMessage"></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Decline</button>
                <button type="button" id="acceptChatBtn" class="btn btn-primary">Accept</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
const socket = io();
const username = '{{ username }}';
let currentThreadId = null;
let currentPrivateRoomId = null;
let currentTargetUser = null;
let localStream = null;
let peerConnection = null;
const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

// DOM elements
const threadsList = document.getElementById('threadsList');
const usersList = document.getElementById('usersList');
const publicChatArea = document.getElementById('publicChatArea');
const privateChatArea = document.getElementById('privateChatArea');
const publicChatMessages = document.getElementById('publicChatMessages');
const privateChatMessages = document.getElementById('privateChatMessages');
const publicChatTitle = document.getElementById('publicChatTitle');
const privateChatTitle = document.getElementById('privateChatTitle');
const publicMessageInput = document.getElementById('publicMessageInput');
const messageInput = document.getElementById('messageInput');
const publicSendMessageBtn = document.getElementById('publicSendMessageBtn');
const sendMessageBtn = document.getElementById('sendMessageBtn');
const createThreadBtn = document.getElementById('createThreadBtn');
const chatInvitationModal = new bootstrap.Modal(document.getElementById('chatInvitationModal'));
const createThreadModal = new bootstrap.Modal(document.getElementById('createThreadModal'));
let pendingInvitation = null;

// Screen sharing elements (same as before)
const shareScreenBtn = document.getElementById('shareScreenBtn');
const stopScreenBtn = document.getElementById('stopScreenBtn');
const screenShareContainer = document.getElementById('screenShareContainer');
const screenVideo = document.getElementById('screenVideo');
const stopViewingBtn = document.getElementById('stopViewingBtn');
const closeChatBtn = document.getElementById('closeChatBtn');

// Socket events
socket.on('connect', () => {
    console.log('Connected');
    loadThreads();
    loadUsers();
});

socket.on('threads_updated', (data) => {
    updateThreadsList(data.threads);
});

socket.on('user_list_updated', (data) => {
    updateUsersList(data.users.filter(u => u !== username));
});

socket.on('public_message_received', (data) => {
    if (currentThreadId === data.thread_id) {
        displayPublicMessage(data);
    }
});

socket.on('thread_messages', (data) => {
    if (currentThreadId === data.thread_id) {
        publicChatMessages.innerHTML = '';
        data.messages.forEach(displayPublicMessage);
        publicChatMessages.scrollTop = publicChatMessages.scrollHeight;
        togglePublicInput(true);
    }
});

socket.on('private_chat_invitation', (data) => {
    pendingInvitation = data;
    document.getElementById('invitationMessage').textContent = `${data.from_user} wants to chat privately.`;
    chatInvitationModal.show();
});

socket.on('private_chat_started', (data) => {
    openPrivateChat(data.target_user, data.room_id, data.messages);
});

socket.on('private_message_received', (data) => {
    if (currentPrivateRoomId === data.room_id) {
        displayPrivateMessage(data);
    }
});

// Screen sharing events (same as before)
socket.on('screen_share_started', (data) => {
    showScreenShareNotification(`${data.username} is sharing screen`);
});

socket.on('screen_share_stopped', (data) => {
    hideScreenShare();
    showScreenShareNotification(`${data.username} stopped sharing`);
});

socket.on('screen_share_offer_received', (data) => handleScreenShareOffer(data.offer, data.from_user));
socket.on('screen_share_answer_received', (data) => {
    if (peerConnection) peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
});
socket.on('screen_share_ice_candidate_received', (data) => {
    if (peerConnection) peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
});

// Load data
function loadThreads() {
    fetch('/threads').then(res => res.json()).then(data => updateThreadsList(data.threads || []));
}

function loadUsers() {
    fetch('/users').then(res => res.json()).then(data => updateUsersList(data.users || []));
}

function updateThreadsList(threads) {
    threadsList.innerHTML = '';
    if (threads.length === 0) {
        threadsList.innerHTML = '<div class="thread-item text-muted p-3">No threads yet. Create one!</div>';
        return;
    }
    threads.forEach(thread => {
        const item = document.createElement('div');
        item.className = `thread-item ${currentThreadId === thread.id ? 'active' : ''}`;
        item.innerHTML = `<div><strong>#${thread.title}</strong><small class="d-block text-muted">${thread.description || ''} | ${thread.message_count} messages</small></div>`;
        item.addEventListener('click', () => joinThread(thread.id, thread.title, thread.description));
        threadsList.appendChild(item);
    });
}

function updateUsersList(users) {
    usersList.innerHTML = '';
    if (users.length === 0) {
        usersList.innerHTML = '<div class="p-3 text-muted">No other users</div>';
        return;
    }
    users.forEach(user => {
        const item = document.createElement('div');
        item.className = 'border-bottom py-2 px-3 d-flex justify-content-between align-items-center';
        item.innerHTML = `<span>${user}</span><button class="btn btn-sm btn-outline-primary start-chat-btn" data-username="${user}">DM</button>`;
        item.querySelector('.start-chat-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            startPrivateChat(user);
        });
        usersList.appendChild(item);
    });
}

function joinThread(threadId, title, description) {
    currentThreadId = threadId;
    publicChatTitle.innerHTML = `<strong>#${title}</strong> ${description ? `<small>${description}</small>` : ''}`;
    publicChatMessages.innerHTML = '<div class="text-muted p-3">Loading messages...</div>';
    socket.emit('join_thread', { thread_id: threadId });
    updateThreadsList(threadsList.children); // Refresh active state
    togglePublicInput(true);
    publicChatMessages.classList.remove('d-none');
}

// Create thread modal
createThreadBtn.addEventListener('click', () => createThreadModal.show());
document.getElementById('submitThreadBtn').addEventListener('click', () => {
    const title = document.getElementById('threadTitle').value.trim();
    const desc = document.getElementById('threadDescription').value.trim();
    if (title) {
        socket.emit('create_thread', { title, description: desc });
        createThreadModal.hide();
        document.getElementById('threadTitle').value = '';
        document.getElementById('threadDescription').value = '';
    }
});

// Public messaging
function sendPublicMessage() {
    const msg = publicMessageInput.value.trim();
    if (msg && currentThreadId) {
        socket.emit('public_message', { thread_id: currentThreadId, message: msg });
        publicMessageInput.value = '';
    }
}
publicSendMessageBtn.addEventListener('click', sendPublicMessage);
publicMessageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendPublicMessage(); });

function togglePublicInput(show) {
    document.getElementById('publicInputGroup').classList.toggle('d-none', !show);
    publicChatMessages.classList.toggle('d-none', !show);
}

function displayPublicMessage(msg) {
    const div = document.createElement('div');
    div.className = `message ${msg.username === username ? 'own' : 'other'}`;
    const mentions = msg.message.replace(/@(\w+)/g, '<span class="mention">@$1</span>');
    div.innerHTML = `
        <div class="d-flex justify-content-between align-items-start">
            <div>
                <strong>${msg.username}:</strong> ${mentions}
                <div class="reactions mt-1"></div>
            </div>
            <small class="text-muted">${msg.timestamp}</small>
        </div>
    `;
    // Add reactions (basic: thumbs up/down)
    const reactionsDiv = div.querySelector('.reactions');
    ['👍', '👎'].forEach(emoji => {
        const btn = document.createElement('span');
        btn.className = 'reaction';
        btn.textContent = emoji;
        btn.dataset.emoji = emoji;
        btn.dataset.msgId = msg.id;
        btn.addEventListener('click', () => reactToMessage(msg.id, emoji));
        reactionsDiv.appendChild(btn);
    });
    publicChatMessages.appendChild(div);
    publicChatMessages.scrollTop = publicChatMessages.scrollHeight;
}

// Private chat functions (adapted from original)
function startPrivateChat(targetUser) {
    socket.emit('start_private_chat', { target_user: targetUser });
}

document.getElementById('acceptChatBtn').addEventListener('click', () => {
    if (pendingInvitation) {
        socket.emit('join_private_chat', { room_id: pendingInvitation.room_id });
        openPrivateChat(pendingInvitation.from_user, pendingInvitation.room_id, []);
        chatInvitationModal.hide();
        pendingInvitation = null;
    }
});

function openPrivateChat(targetUser, roomId, messages) {
    currentTargetUser = targetUser;
    currentPrivateRoomId = roomId;
    publicChatArea.classList.add('d-none');
    privateChatArea.classList.remove('d-none');
    privateChatTitle.textContent = `Private with ${targetUser}`;
    privateChatMessages.innerHTML = '';
    messages.forEach(displayPrivateMessage);
    privateChatMessages.scrollTop = privateChatMessages.scrollHeight;
}

function displayPrivateMessage(msg) {
    const div = document.createElement('div');
    div.className = `message ${msg.username === username ? 'own' : 'other'}`;
    div.innerHTML = `
        <div class="d-flex justify-content-between align-items-start">
            <div><strong>${msg.username}:</strong> ${msg.message}</div>
            <small class="text-muted">${msg.timestamp}</small>
        </div>
    `;
    privateChatMessages.appendChild(div);
    privateChatMessages.scrollTop = privateChatMessages.scrollHeight;
}

function sendPrivateMessage() {
    const msg = messageInput.value.trim();
    if (msg && currentPrivateRoomId) {
        socket.emit('private_message', { room_id: currentPrivateRoomId, message: msg });
        messageInput.value = '';
    }
}
sendMessageBtn.addEventListener('click', sendPrivateMessage);
messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendPrivateMessage(); });

closeChatBtn.addEventListener('click', () => {
    privateChatArea.classList.add('d-none');
    publicChatArea.classList.remove('d-none');
    currentPrivateRoomId = null;
    currentTargetUser = null;
    stopScreenSharing();
});

// Reactions (basic implementation)
function reactToMessage(msgId, emoji) {
    socket.emit('react_message', { thread_id: currentThreadId, message_id: msgId, emoji });
}

// Screen sharing (unchanged from your original, but integrated)
shareScreenBtn.addEventListener('click', startScreenSharing);
stopScreenBtn.addEventListener('click', stopScreenSharing);
stopViewingBtn.addEventListener('click', hideScreenShare);

async function startScreenSharing() {
    try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        shareScreenBtn.classList.add('d-none');
        stopScreenBtn.classList.remove('d-none');
        socket.emit('start_screen_share', { room_id: currentPrivateRoomId });
        await setupWebRTCConnection();
        localStream.getVideoTracks()[0].addEventListener('ended', stopScreenSharing);
    } catch (err) {
        console.error(err);
        alert('Failed to share screen.');
    }
}

function stopScreenSharing() {
    if (localStream) localStream.getTracks().forEach(track => track.stop());
    if (peerConnection) peerConnection.close();
    localStream = null;
    peerConnection = null;
    shareScreenBtn.classList.remove('d-none');
    stopScreenBtn.classList.add('d-none');
    socket.emit('stop_screen_share', { room_id: currentPrivateRoomId });
    hideScreenShare();
}

async function setupWebRTCConnection() {
    peerConnection = new RTCPeerConnection(rtcConfig);
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    peerConnection.onicecandidate = (e) => {
        if (e.candidate) socket.emit('screen_share_ice_candidate', { room_id: currentPrivateRoomId, candidate: e.candidate });
    };
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit('screen_share_offer', { room_id: currentPrivateRoomId, offer });
}

async function handleScreenShareOffer(offer, fromUser) {
    if (!peerConnection) {
        peerConnection = new RTCPeerConnection(rtcConfig);
        peerConnection.ontrack = (e) => {
            screenVideo.srcObject = e.streams[0];
            showScreenShare();
        };
        peerConnection.onicecandidate = (e) => {
            if (e.candidate) socket.emit('screen_share_ice_candidate', { room_id: currentPrivateRoomId, candidate: e.candidate });
        };
    }
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit('screen_share_answer', { room_id: currentPrivateRoomId, answer, target_user: fromUser });
}

function showScreenShare() { screenShareContainer.classList.remove('d-none'); }
function hideScreenShare() {
    screenShareContainer.classList.add('d-none');
    if (screenVideo.srcObject) screenVideo.srcObject.getTracks().forEach(track => track.stop());
    screenVideo.srcObject = null;
    if (peerConnection) { peerConnection.close(); peerConnection = null; }
}
function showScreenShareNotification(msg) { console.log(msg); /* Add toast later */ }
</script>
{% endblock %}
